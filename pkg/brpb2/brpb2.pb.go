// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: brpb2.proto

package backup2

import (
	"fmt"
	"io"
	"math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	brpb "github.com/pingcap/kvproto/pkg/brpb"
	encryptionpb "github.com/pingcap/kvproto/pkg/encryptionpb"
	metapb "github.com/pingcap/kvproto/pkg/metapb"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// DataFileGroup2 is the merged file info in log-backup
type DataFileGroup2 struct {
	// Path of the file.
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// Partitions of the file.
	DataFilesInfo []*DataFileInfo2 `protobuf:"bytes,2,rep,name=data_files_info,json=dataFilesInfo,proto3" json:"data_files_info,omitempty"`
	/// Below are extra information of the file, for better filtering files.
	// The min ts of the keys in the file.
	MinTs uint64 `protobuf:"varint,3,opt,name=min_ts,json=minTs,proto3" json:"min_ts,omitempty"`
	// The max ts of the keys in the file.
	MaxTs uint64 `protobuf:"varint,4,opt,name=max_ts,json=maxTs,proto3" json:"max_ts,omitempty"`
	// The resolved ts of the region when saving the file.
	MinResolvedTs uint64 `protobuf:"varint,5,opt,name=min_resolved_ts,json=minResolvedTs,proto3" json:"min_resolved_ts,omitempty"`
	// The file length after compressed.
	Length uint64 `protobuf:"varint,6,opt,name=length,proto3" json:"length,omitempty"`
}

func (m *DataFileGroup2) Reset()         { *m = DataFileGroup2{} }
func (m *DataFileGroup2) String() string { return proto.CompactTextString(m) }
func (*DataFileGroup2) ProtoMessage()    {}
func (*DataFileGroup2) Descriptor() ([]byte, []int) {
	return fileDescriptor_932d13e6cb1b2ecc, []int{0}
}
func (m *DataFileGroup2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataFileGroup2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataFileGroup2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataFileGroup2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataFileGroup2.Merge(m, src)
}
func (m *DataFileGroup2) XXX_Size() int {
	return m.Size()
}
func (m *DataFileGroup2) XXX_DiscardUnknown() {
	xxx_messageInfo_DataFileGroup2.DiscardUnknown(m)
}

var xxx_messageInfo_DataFileGroup2 proto.InternalMessageInfo

func (m *DataFileGroup2) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *DataFileGroup2) GetDataFilesInfo() []*DataFileInfo2 {
	if m != nil {
		return m.DataFilesInfo
	}
	return nil
}

func (m *DataFileGroup2) GetMinTs() uint64 {
	if m != nil {
		return m.MinTs
	}
	return 0
}

func (m *DataFileGroup2) GetMaxTs() uint64 {
	if m != nil {
		return m.MaxTs
	}
	return 0
}

func (m *DataFileGroup2) GetMinResolvedTs() uint64 {
	if m != nil {
		return m.MinResolvedTs
	}
	return 0
}

func (m *DataFileGroup2) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

type DataFileInfo2 struct {
	// Checksum of the plaintext file, i.e., pre-compression, pre-encryption.
	Sha256 []byte `protobuf:"bytes,1,opt,name=sha256,proto3" json:"sha256,omitempty"`
	// Path of the file.
	Path            string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	NumberOfEntries int64  `protobuf:"varint,3,opt,name=number_of_entries,json=numberOfEntries,proto3" json:"number_of_entries,omitempty"`
	/// Below are extra information of the file, for better filtering files.
	// The min ts of the keys in the file.
	MinTs uint64 `protobuf:"varint,4,opt,name=min_ts,json=minTs,proto3" json:"min_ts,omitempty"`
	// The max ts of the keys in the file.
	MaxTs uint64 `protobuf:"varint,5,opt,name=max_ts,json=maxTs,proto3" json:"max_ts,omitempty"`
	// The resolved ts of the region when saving the file.
	ResolvedTs uint64 `protobuf:"varint,6,opt,name=resolved_ts,json=resolvedTs,proto3" json:"resolved_ts,omitempty"`
	// The region of the file.
	RegionId int64 `protobuf:"varint,7,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	// The key range of the file.
	// Encoded and starts with 'z'(internal key).
	StartKey []byte `protobuf:"bytes,8,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey   []byte `protobuf:"bytes,9,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	// The column family of the file.
	Cf string `protobuf:"bytes,10,opt,name=cf,proto3" json:"cf,omitempty"`
	// The operation type of the file.
	Type brpb.FileType `protobuf:"varint,11,opt,name=type,proto3,enum=backup.FileType" json:"type,omitempty"`
	// Whether the data file contains meta keys(m prefixed keys) only.
	IsMeta bool `protobuf:"varint,12,opt,name=is_meta,json=isMeta,proto3" json:"is_meta,omitempty"`
	// The table ID of the file contains, when `is_meta` is true, would be ignored.
	TableId int64 `protobuf:"varint,13,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	// The file length.
	Length uint64 `protobuf:"varint,14,opt,name=length,proto3" json:"length,omitempty"`
	// The minimal begin ts in default cf if this file is write cf.
	MinBeginTsInDefaultCf uint64 `protobuf:"varint,15,opt,name=min_begin_ts_in_default_cf,json=minBeginTsInDefaultCf,proto3" json:"min_begin_ts_in_default_cf,omitempty"`
	// Offset of the partition. compatible with V1 and V2.
	RangeOffset uint64 `protobuf:"varint,16,opt,name=range_offset,json=rangeOffset,proto3" json:"range_offset,omitempty"`
	// The range length of the merged file, if it exists.
	RangeLength uint64 `protobuf:"varint,17,opt,name=range_length,json=rangeLength,proto3" json:"range_length,omitempty"`
	// The compression type for the file.
	CompressionType brpb.CompressionType `protobuf:"varint,18,opt,name=compression_type,json=compressionType,proto3,enum=backup.CompressionType" json:"compression_type,omitempty"`
	// The CRC64XOR of all contents of the file.
	// In older versions, this might be empty.
	Crc64Xor uint64 `protobuf:"varint,19,opt,name=crc64xor,proto3" json:"crc64xor,omitempty"`
	// The original region range the log file belongs to.
	// In older versions, this might be empty.
	// This may not be accurative: file may contain keys less than this.
	RegionStartKey []byte `protobuf:"bytes,20,opt,name=region_start_key,json=regionStartKey,proto3" json:"region_start_key,omitempty"`
	// The original region range the log file belongs to.
	// In older versions, this might be empty.
	// This may not be accurative: file may contain keys greater than this.
	RegionEndKey []byte `protobuf:"bytes,21,opt,name=region_end_key,json=regionEndKey,proto3" json:"region_end_key,omitempty"`
	// The region epoch that the log file belongs to.
	// In older versions, this might be empty.
	// If a region get split or merged during observing, the file may contain multi epoches.
	// This may not be complete: file may contain records from other versions.
	//
	// If there is exactly one epoch,
	// `region_start_key` and `region_end_key` must match this epoch.
	RegionEpoch []*metapb.RegionEpoch `protobuf:"bytes,22,rep,name=region_epoch,json=regionEpoch,proto3" json:"region_epoch,omitempty"`
	// Encryption information of this data file, not set if plaintext.
	FileEncryptionInfo *encryptionpb.FileEncryptionInfo `protobuf:"bytes,23,opt,name=file_encryption_info,json=fileEncryptionInfo,proto3" json:"file_encryption_info,omitempty"`
}

func (m *DataFileInfo2) Reset()         { *m = DataFileInfo2{} }
func (m *DataFileInfo2) String() string { return proto.CompactTextString(m) }
func (*DataFileInfo2) ProtoMessage()    {}
func (*DataFileInfo2) Descriptor() ([]byte, []int) {
	return fileDescriptor_932d13e6cb1b2ecc, []int{1}
}
func (m *DataFileInfo2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataFileInfo2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataFileInfo2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataFileInfo2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataFileInfo2.Merge(m, src)
}
func (m *DataFileInfo2) XXX_Size() int {
	return m.Size()
}
func (m *DataFileInfo2) XXX_DiscardUnknown() {
	xxx_messageInfo_DataFileInfo2.DiscardUnknown(m)
}

var xxx_messageInfo_DataFileInfo2 proto.InternalMessageInfo

func (m *DataFileInfo2) GetSha256() []byte {
	if m != nil {
		return m.Sha256
	}
	return nil
}

func (m *DataFileInfo2) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *DataFileInfo2) GetNumberOfEntries() int64 {
	if m != nil {
		return m.NumberOfEntries
	}
	return 0
}

func (m *DataFileInfo2) GetMinTs() uint64 {
	if m != nil {
		return m.MinTs
	}
	return 0
}

func (m *DataFileInfo2) GetMaxTs() uint64 {
	if m != nil {
		return m.MaxTs
	}
	return 0
}

func (m *DataFileInfo2) GetResolvedTs() uint64 {
	if m != nil {
		return m.ResolvedTs
	}
	return 0
}

func (m *DataFileInfo2) GetRegionId() int64 {
	if m != nil {
		return m.RegionId
	}
	return 0
}

func (m *DataFileInfo2) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *DataFileInfo2) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *DataFileInfo2) GetCf() string {
	if m != nil {
		return m.Cf
	}
	return ""
}

func (m *DataFileInfo2) GetType() brpb.FileType {
	if m != nil {
		return m.Type
	}
	return brpb.FileType_Delete
}

func (m *DataFileInfo2) GetIsMeta() bool {
	if m != nil {
		return m.IsMeta
	}
	return false
}

func (m *DataFileInfo2) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *DataFileInfo2) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *DataFileInfo2) GetMinBeginTsInDefaultCf() uint64 {
	if m != nil {
		return m.MinBeginTsInDefaultCf
	}
	return 0
}

func (m *DataFileInfo2) GetRangeOffset() uint64 {
	if m != nil {
		return m.RangeOffset
	}
	return 0
}

func (m *DataFileInfo2) GetRangeLength() uint64 {
	if m != nil {
		return m.RangeLength
	}
	return 0
}

func (m *DataFileInfo2) GetCompressionType() brpb.CompressionType {
	if m != nil {
		return m.CompressionType
	}
	return brpb.CompressionType_UNKNOWN
}

func (m *DataFileInfo2) GetCrc64Xor() uint64 {
	if m != nil {
		return m.Crc64Xor
	}
	return 0
}

func (m *DataFileInfo2) GetRegionStartKey() []byte {
	if m != nil {
		return m.RegionStartKey
	}
	return nil
}

func (m *DataFileInfo2) GetRegionEndKey() []byte {
	if m != nil {
		return m.RegionEndKey
	}
	return nil
}

func (m *DataFileInfo2) GetRegionEpoch() []*metapb.RegionEpoch {
	if m != nil {
		return m.RegionEpoch
	}
	return nil
}

func (m *DataFileInfo2) GetFileEncryptionInfo() *encryptionpb.FileEncryptionInfo {
	if m != nil {
		return m.FileEncryptionInfo
	}
	return nil
}

func init() {
	proto.RegisterType((*DataFileGroup2)(nil), "backup2.DataFileGroup2")
	proto.RegisterType((*DataFileInfo2)(nil), "backup2.DataFileInfo2")
}

func init() { proto.RegisterFile("brpb2.proto", fileDescriptor_932d13e6cb1b2ecc) }

var fileDescriptor_932d13e6cb1b2ecc = []byte{
	// 700 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x94, 0xcb, 0x6e, 0x1b, 0x37,
	0x14, 0x86, 0x35, 0xb2, 0x2c, 0x8d, 0xa9, 0xab, 0xe9, 0xdb, 0x54, 0x05, 0x54, 0xd5, 0x30, 0x0a,
	0xa1, 0x8b, 0x29, 0x30, 0x6d, 0x0d, 0xb4, 0x8b, 0x2e, 0x7c, 0x69, 0x20, 0x24, 0x81, 0x81, 0x89,
	0xf6, 0x03, 0x6a, 0x86, 0x23, 0x11, 0x92, 0xc8, 0x01, 0x49, 0x19, 0xd6, 0x5b, 0x64, 0xe9, 0x65,
	0x76, 0xce, 0xa3, 0x78, 0x69, 0x64, 0xe5, 0x65, 0x60, 0xbd, 0x48, 0xc0, 0xc3, 0xd1, 0xc5, 0x48,
	0x56, 0xe2, 0xf9, 0xfe, 0x83, 0xe1, 0xf9, 0xf9, 0x8b, 0x44, 0xd5, 0xa1, 0xcc, 0x86, 0x81, 0x9f,
	0x49, 0xa1, 0x05, 0xae, 0x0c, 0x49, 0x3c, 0x99, 0x67, 0x41, 0x1b, 0x19, 0x6a, 0x61, 0xbb, 0x36,
	0xa3, 0x9a, 0xac, 0x2b, 0x4c, 0x79, 0x2c, 0x17, 0x99, 0x66, 0x82, 0xaf, 0xd9, 0xe1, 0x48, 0x8c,
	0x04, 0x2c, 0xff, 0x30, 0xab, 0x9c, 0x36, 0xe5, 0x5c, 0x69, 0x58, 0x5a, 0x70, 0xfa, 0xc5, 0x41,
	0x8d, 0x2b, 0xa2, 0xc9, 0xff, 0x6c, 0x4a, 0xdf, 0x48, 0x31, 0xcf, 0x02, 0x8c, 0x51, 0x29, 0x23,
	0x7a, 0xec, 0x39, 0x5d, 0xa7, 0xb7, 0x17, 0xc2, 0x1a, 0xff, 0x87, 0x9a, 0x09, 0xd1, 0x24, 0x4a,
	0xd9, 0x94, 0xaa, 0x88, 0xf1, 0x54, 0x78, 0xc5, 0xee, 0x4e, 0xaf, 0x1a, 0x1c, 0xfb, 0xf9, 0x78,
	0xfe, 0xea, 0x2b, 0x7d, 0x9e, 0x8a, 0x20, 0xac, 0x27, 0x79, 0xa9, 0x4c, 0x8d, 0x8f, 0x50, 0x79,
	0xc6, 0x78, 0xa4, 0x95, 0xb7, 0xd3, 0x75, 0x7a, 0xa5, 0x70, 0x77, 0xc6, 0xf8, 0x40, 0x01, 0x26,
	0x77, 0x06, 0x97, 0x72, 0x4c, 0xee, 0x06, 0x0a, 0xff, 0x86, 0x9a, 0xa6, 0x5b, 0x52, 0x25, 0xa6,
	0xb7, 0x34, 0x31, 0xfa, 0x2e, 0xe8, 0xf5, 0x19, 0xe3, 0x61, 0x4e, 0x07, 0x0a, 0x1f, 0xa3, 0xf2,
	0x94, 0xf2, 0x91, 0x1e, 0x7b, 0x65, 0x90, 0xf3, 0xea, 0xf4, 0xb1, 0x8c, 0xea, 0xaf, 0xc6, 0x31,
	0x9d, 0x6a, 0x4c, 0x82, 0xbf, 0xcf, 0xc1, 0x55, 0x2d, 0xcc, 0xab, 0xb5, 0xd7, 0xe2, 0x96, 0xd7,
	0xdf, 0xd1, 0x3e, 0x9f, 0xcf, 0x86, 0x54, 0x46, 0x22, 0x8d, 0x28, 0xd7, 0x92, 0x51, 0x3b, 0xf6,
	0x4e, 0xd8, 0xb4, 0xc2, 0x4d, 0x7a, 0x6d, 0xf1, 0x96, 0xaf, 0xd2, 0x8f, 0x7d, 0xed, 0x6e, 0xfb,
	0xfa, 0x05, 0x55, 0xb7, 0x3d, 0xd9, 0xa1, 0x91, 0xdc, 0x18, 0xfa, 0x19, 0xed, 0x49, 0x3a, 0x62,
	0x82, 0x47, 0x2c, 0xf1, 0x2a, 0xb0, 0xa5, 0x6b, 0x41, 0x3f, 0x31, 0xa2, 0xd2, 0x44, 0xea, 0x68,
	0x42, 0x17, 0x9e, 0x0b, 0x36, 0x5c, 0x00, 0x6f, 0xe9, 0x02, 0x9f, 0xa0, 0x0a, 0xe5, 0x09, 0x48,
	0x7b, 0xd6, 0x21, 0xe5, 0x89, 0x11, 0x1a, 0xa8, 0x18, 0xa7, 0x1e, 0x02, 0x7f, 0xc5, 0x38, 0xc5,
	0x67, 0xa8, 0xa4, 0x17, 0x19, 0xf5, 0xaa, 0x5d, 0xa7, 0xd7, 0x08, 0x5a, 0x79, 0x7c, 0xbe, 0x39,
	0xaa, 0xc1, 0x22, 0xa3, 0x21, 0xa8, 0xe6, 0x73, 0x4c, 0x45, 0xe6, 0x4f, 0xe6, 0xd5, 0xba, 0x4e,
	0xcf, 0x0d, 0xcb, 0x4c, 0xbd, 0xa7, 0x9a, 0xe0, 0x9f, 0x90, 0xab, 0xc9, 0x70, 0x4a, 0xcd, 0x80,
	0x75, 0x18, 0xb0, 0x02, 0x75, 0x3f, 0xd9, 0x4a, 0xa3, 0xb1, 0x9d, 0x06, 0xfe, 0x07, 0xb5, 0xcd,
	0x19, 0x0d, 0xe9, 0x08, 0x4e, 0x2a, 0x62, 0x3c, 0x4a, 0x68, 0x4a, 0xe6, 0x53, 0x1d, 0xc5, 0xa9,
	0xd7, 0x84, 0xde, 0xa3, 0x19, 0xe3, 0x17, 0xa6, 0x61, 0xa0, 0xfa, 0xfc, 0xca, 0xaa, 0x97, 0x29,
	0xfe, 0x15, 0xd5, 0x24, 0xe1, 0x23, 0x1a, 0x89, 0x34, 0x55, 0x54, 0x7b, 0x2d, 0x68, 0xae, 0x02,
	0xbb, 0x01, 0xb4, 0x69, 0xc9, 0xf7, 0xde, 0xdf, 0x6a, 0x79, 0x67, 0x07, 0xb8, 0x40, 0xad, 0x58,
	0xcc, 0x32, 0x49, 0x95, 0x32, 0x47, 0x0b, 0xf6, 0x31, 0xd8, 0x3f, 0x59, 0xd9, 0xbf, 0xdc, 0xe8,
	0x70, 0x0a, 0xcd, 0xf8, 0x35, 0xc0, 0x6d, 0xe4, 0xc6, 0x32, 0x3e, 0xff, 0xeb, 0x4e, 0x48, 0xef,
	0x00, 0xb6, 0x58, 0xd7, 0xb8, 0x87, 0x5a, 0x79, 0x6a, 0x9b, 0x7c, 0x0e, 0x21, 0x84, 0x86, 0xe5,
	0x1f, 0x56, 0x29, 0x9d, 0xa1, 0x9c, 0x44, 0xab, 0xb0, 0x8e, 0xa0, 0xaf, 0x66, 0xe9, 0xb5, 0x8d,
	0xec, 0x1c, 0xd5, 0x56, 0x5d, 0x99, 0x88, 0xc7, 0xde, 0x31, 0xdc, 0xb4, 0x03, 0x3f, 0xbf, 0xf3,
	0xa1, 0xed, 0x35, 0x52, 0x58, 0x95, 0x9b, 0x02, 0x87, 0xe8, 0xd0, 0xdc, 0xcf, 0x68, 0xf3, 0x1a,
	0xd8, 0x9b, 0x7a, 0xd2, 0x75, 0x7a, 0xd5, 0xa0, 0xeb, 0xbf, 0x7a, 0x25, 0x4c, 0xe0, 0xd7, 0x6b,
	0x60, 0x6e, 0x49, 0x88, 0xd3, 0xef, 0xd8, 0xc5, 0xbf, 0xf7, 0x0f, 0xae, 0xf3, 0xe9, 0xc1, 0x75,
	0x9e, 0x3f, 0xbb, 0xce, 0xe3, 0x4b, 0xc7, 0x79, 0x7a, 0xe9, 0x38, 0x5f, 0x5f, 0x3a, 0xce, 0xc7,
	0x65, 0xa7, 0x70, 0xbf, 0xec, 0x14, 0x9e, 0x96, 0x9d, 0xc2, 0xf3, 0xb2, 0x53, 0x40, 0x2d, 0x21,
	0x47, 0xbe, 0x66, 0x93, 0x5b, 0x7f, 0x72, 0x0b, 0x6f, 0xcb, 0xb0, 0x0c, 0x3f, 0x7f, 0x7e, 0x0b,
	0x00, 0x00, 0xff, 0xff, 0x2d, 0xb7, 0xe3, 0xe7, 0xcf, 0x04, 0x00, 0x00,
}

func (m *DataFileGroup2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataFileGroup2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataFileGroup2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Length != 0 {
		i = encodeVarintBrpb2(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x30
	}
	if m.MinResolvedTs != 0 {
		i = encodeVarintBrpb2(dAtA, i, uint64(m.MinResolvedTs))
		i--
		dAtA[i] = 0x28
	}
	if m.MaxTs != 0 {
		i = encodeVarintBrpb2(dAtA, i, uint64(m.MaxTs))
		i--
		dAtA[i] = 0x20
	}
	if m.MinTs != 0 {
		i = encodeVarintBrpb2(dAtA, i, uint64(m.MinTs))
		i--
		dAtA[i] = 0x18
	}
	if len(m.DataFilesInfo) > 0 {
		for iNdEx := len(m.DataFilesInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DataFilesInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb2(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintBrpb2(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DataFileInfo2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataFileInfo2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataFileInfo2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FileEncryptionInfo != nil {
		{
			size, err := m.FileEncryptionInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.RegionEpoch) > 0 {
		for iNdEx := len(m.RegionEpoch) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RegionEpoch[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb2(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.RegionEndKey) > 0 {
		i -= len(m.RegionEndKey)
		copy(dAtA[i:], m.RegionEndKey)
		i = encodeVarintBrpb2(dAtA, i, uint64(len(m.RegionEndKey)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.RegionStartKey) > 0 {
		i -= len(m.RegionStartKey)
		copy(dAtA[i:], m.RegionStartKey)
		i = encodeVarintBrpb2(dAtA, i, uint64(len(m.RegionStartKey)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.Crc64Xor != 0 {
		i = encodeVarintBrpb2(dAtA, i, uint64(m.Crc64Xor))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.CompressionType != 0 {
		i = encodeVarintBrpb2(dAtA, i, uint64(m.CompressionType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.RangeLength != 0 {
		i = encodeVarintBrpb2(dAtA, i, uint64(m.RangeLength))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.RangeOffset != 0 {
		i = encodeVarintBrpb2(dAtA, i, uint64(m.RangeOffset))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.MinBeginTsInDefaultCf != 0 {
		i = encodeVarintBrpb2(dAtA, i, uint64(m.MinBeginTsInDefaultCf))
		i--
		dAtA[i] = 0x78
	}
	if m.Length != 0 {
		i = encodeVarintBrpb2(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x70
	}
	if m.TableId != 0 {
		i = encodeVarintBrpb2(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x68
	}
	if m.IsMeta {
		i--
		if m.IsMeta {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.Type != 0 {
		i = encodeVarintBrpb2(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x58
	}
	if len(m.Cf) > 0 {
		i -= len(m.Cf)
		copy(dAtA[i:], m.Cf)
		i = encodeVarintBrpb2(dAtA, i, uint64(len(m.Cf)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintBrpb2(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintBrpb2(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x42
	}
	if m.RegionId != 0 {
		i = encodeVarintBrpb2(dAtA, i, uint64(m.RegionId))
		i--
		dAtA[i] = 0x38
	}
	if m.ResolvedTs != 0 {
		i = encodeVarintBrpb2(dAtA, i, uint64(m.ResolvedTs))
		i--
		dAtA[i] = 0x30
	}
	if m.MaxTs != 0 {
		i = encodeVarintBrpb2(dAtA, i, uint64(m.MaxTs))
		i--
		dAtA[i] = 0x28
	}
	if m.MinTs != 0 {
		i = encodeVarintBrpb2(dAtA, i, uint64(m.MinTs))
		i--
		dAtA[i] = 0x20
	}
	if m.NumberOfEntries != 0 {
		i = encodeVarintBrpb2(dAtA, i, uint64(m.NumberOfEntries))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintBrpb2(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sha256) > 0 {
		i -= len(m.Sha256)
		copy(dAtA[i:], m.Sha256)
		i = encodeVarintBrpb2(dAtA, i, uint64(len(m.Sha256)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintBrpb2(dAtA []byte, offset int, v uint64) int {
	offset -= sovBrpb2(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DataFileGroup2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovBrpb2(uint64(l))
	}
	if len(m.DataFilesInfo) > 0 {
		for _, e := range m.DataFilesInfo {
			l = e.Size()
			n += 1 + l + sovBrpb2(uint64(l))
		}
	}
	if m.MinTs != 0 {
		n += 1 + sovBrpb2(uint64(m.MinTs))
	}
	if m.MaxTs != 0 {
		n += 1 + sovBrpb2(uint64(m.MaxTs))
	}
	if m.MinResolvedTs != 0 {
		n += 1 + sovBrpb2(uint64(m.MinResolvedTs))
	}
	if m.Length != 0 {
		n += 1 + sovBrpb2(uint64(m.Length))
	}
	return n
}

func (m *DataFileInfo2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sha256)
	if l > 0 {
		n += 1 + l + sovBrpb2(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovBrpb2(uint64(l))
	}
	if m.NumberOfEntries != 0 {
		n += 1 + sovBrpb2(uint64(m.NumberOfEntries))
	}
	if m.MinTs != 0 {
		n += 1 + sovBrpb2(uint64(m.MinTs))
	}
	if m.MaxTs != 0 {
		n += 1 + sovBrpb2(uint64(m.MaxTs))
	}
	if m.ResolvedTs != 0 {
		n += 1 + sovBrpb2(uint64(m.ResolvedTs))
	}
	if m.RegionId != 0 {
		n += 1 + sovBrpb2(uint64(m.RegionId))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovBrpb2(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovBrpb2(uint64(l))
	}
	l = len(m.Cf)
	if l > 0 {
		n += 1 + l + sovBrpb2(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovBrpb2(uint64(m.Type))
	}
	if m.IsMeta {
		n += 2
	}
	if m.TableId != 0 {
		n += 1 + sovBrpb2(uint64(m.TableId))
	}
	if m.Length != 0 {
		n += 1 + sovBrpb2(uint64(m.Length))
	}
	if m.MinBeginTsInDefaultCf != 0 {
		n += 1 + sovBrpb2(uint64(m.MinBeginTsInDefaultCf))
	}
	if m.RangeOffset != 0 {
		n += 2 + sovBrpb2(uint64(m.RangeOffset))
	}
	if m.RangeLength != 0 {
		n += 2 + sovBrpb2(uint64(m.RangeLength))
	}
	if m.CompressionType != 0 {
		n += 2 + sovBrpb2(uint64(m.CompressionType))
	}
	if m.Crc64Xor != 0 {
		n += 2 + sovBrpb2(uint64(m.Crc64Xor))
	}
	l = len(m.RegionStartKey)
	if l > 0 {
		n += 2 + l + sovBrpb2(uint64(l))
	}
	l = len(m.RegionEndKey)
	if l > 0 {
		n += 2 + l + sovBrpb2(uint64(l))
	}
	if len(m.RegionEpoch) > 0 {
		for _, e := range m.RegionEpoch {
			l = e.Size()
			n += 2 + l + sovBrpb2(uint64(l))
		}
	}
	if m.FileEncryptionInfo != nil {
		l = m.FileEncryptionInfo.Size()
		n += 2 + l + sovBrpb2(uint64(l))
	}
	return n
}

func sovBrpb2(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBrpb2(x uint64) (n int) {
	return sovBrpb2(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DataFileGroup2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataFileGroup2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataFileGroup2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb2
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataFilesInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataFilesInfo = append(m.DataFilesInfo, &DataFileInfo2{})
			if err := m.DataFilesInfo[len(m.DataFilesInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinTs", wireType)
			}
			m.MinTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTs", wireType)
			}
			m.MaxTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinResolvedTs", wireType)
			}
			m.MinResolvedTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinResolvedTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataFileInfo2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataFileInfo2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataFileInfo2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sha256", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb2
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sha256 = append(m.Sha256[:0], dAtA[iNdEx:postIndex]...)
			if m.Sha256 == nil {
				m.Sha256 = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb2
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfEntries", wireType)
			}
			m.NumberOfEntries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfEntries |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinTs", wireType)
			}
			m.MinTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTs", wireType)
			}
			m.MaxTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolvedTs", wireType)
			}
			m.ResolvedTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResolvedTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionId", wireType)
			}
			m.RegionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegionId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb2
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb2
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb2
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= brpb.FileType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMeta", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMeta = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinBeginTsInDefaultCf", wireType)
			}
			m.MinBeginTsInDefaultCf = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinBeginTsInDefaultCf |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeOffset", wireType)
			}
			m.RangeOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeOffset |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeLength", wireType)
			}
			m.RangeLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeLength |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressionType", wireType)
			}
			m.CompressionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompressionType |= brpb.CompressionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crc64Xor", wireType)
			}
			m.Crc64Xor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Crc64Xor |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionStartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb2
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionStartKey = append(m.RegionStartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.RegionStartKey == nil {
				m.RegionStartKey = []byte{}
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionEndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb2
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionEndKey = append(m.RegionEndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.RegionEndKey == nil {
				m.RegionEndKey = []byte{}
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionEpoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionEpoch = append(m.RegionEpoch, &metapb.RegionEpoch{})
			if err := m.RegionEpoch[len(m.RegionEpoch)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileEncryptionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileEncryptionInfo == nil {
				m.FileEncryptionInfo = &encryptionpb.FileEncryptionInfo{}
			}
			if err := m.FileEncryptionInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBrpb2(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBrpb2
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBrpb2
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBrpb2
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBrpb2
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBrpb2
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBrpb2
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBrpb2        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBrpb2          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBrpb2 = fmt.Errorf("proto: unexpected end of group")
)
